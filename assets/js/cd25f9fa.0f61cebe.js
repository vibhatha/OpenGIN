"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[945],{7937(e,t,n){n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"overview/architecture/database-schemas","title":"Database Schemas - Detailed Documentation","description":"This document provides comprehensive details about the database schemas used in OpenGIN across MongoDB, Neo4j, and PostgreSQL.","source":"@site/docs/overview/architecture/database-schemas.md","sourceDirName":"overview/architecture","slug":"/overview/architecture/database-schemas","permalink":"/OpenGIN/docs/overview/architecture/database-schemas","draft":false,"unlisted":false,"editUrl":"https://github.com/LDFLK/OpenGIN/tree/main/docs/docs/overview/architecture/database-schemas.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Core API","permalink":"/OpenGIN/docs/overview/architecture/core-api"},"next":{"title":"Quick Start","permalink":"/OpenGIN/docs/getting_started/quick_start"}}');var i=n(4848),s=n(8453);const r={},o="Database Schemas - Detailed Documentation",d={},l=[{value:"Overview",id:"overview",level:2},{value:"MongoDB Schema",id:"mongodb-schema",level:2},{value:"Database Information",id:"database-information",level:3},{value:"Database Information",id:"database-information-1",level:3},{value:"Collections",id:"collections",level:3},{value:"1. metadata",id:"1-metadata",level:4},{value:"2. metadata_test",id:"2-metadata_test",level:4},{value:"Neo4j Schema",id:"neo4j-schema",level:2},{value:"Database Information",id:"database-information-2",level:3},{value:"Node Types",id:"node-types",level:3},{value:"Entity Node",id:"entity-node",level:4},{value:"Relationship Types",id:"relationship-types",level:3},{value:"Relationship Structure",id:"relationship-structure",level:4},{value:"PostgreSQL Schema",id:"postgresql-schema",level:2},{value:"Database Information",id:"database-information-3",level:3},{value:"Database Information",id:"database-information-4",level:3},{value:"Core Tables",id:"core-tables",level:3},{value:"1. Attribute Schema",id:"1-attribute-schema",level:4},{value:"2. Entity Attributes",id:"2-entity-attributes",level:4},{value:"Dynamic Attribute Tables",id:"dynamic-attribute-tables",level:3},{value:"Data Integrity",id:"data-integrity",level:3},{value:"Backup and Restore",id:"backup-and-restore",level:2},{value:"Metadata Store Backup",id:"metadata-store-backup",level:3},{value:"Neo4j Backup",id:"neo4j-backup",level:3},{value:"PostgreSQL Backup",id:"postgresql-backup",level:3},{value:"Reference",id:"reference",level:3}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"database-schemas---detailed-documentation",children:"Database Schemas - Detailed Documentation"})}),"\n",(0,i.jsx)(t.p,{children:"This document provides comprehensive details about the database schemas used in OpenGIN across MongoDB, Neo4j, and PostgreSQL."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(t.p,{children:"OpenGIN uses a multi-database architecture where each database is optimized for specific data types:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Database"}),(0,i.jsx)(t.th,{children:"Purpose"}),(0,i.jsx)(t.th,{children:"Data Stored"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"MongoDB"}),(0,i.jsx)(t.td,{children:"Flexible metadata"}),(0,i.jsx)(t.td,{children:"Key-value metadata pairs"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Neo4j"}),(0,i.jsx)(t.td,{children:"Graph relationships"}),(0,i.jsx)(t.td,{children:"Entity nodes and relationship edges"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"PostgreSQL"}),(0,i.jsx)(t.td,{children:"Structured attributes"}),(0,i.jsx)(t.td,{children:"Time-series attribute data with schemas"})]})]})]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"mongodb-schema",children:"MongoDB Schema"}),"\n",(0,i.jsx)(t.h3,{id:"database-information",children:"Database Information"}),"\n",(0,i.jsx)(t.h3,{id:"database-information-1",children:"Database Information"}),"\n",(0,i.jsx)(t.p,{children:"The Metadata Store is implemented using a document-oriented database to provide flexibility for storing unstructured or semi-structured data. This allows for dynamic metadata fields without rigid schema constraints."}),"\n",(0,i.jsx)(t.h3,{id:"collections",children:"Collections"}),"\n",(0,i.jsx)(t.h4,{id:"1-metadata",children:"1. metadata"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Purpose"}),": Store entity metadata as flexible key-value pairs"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Schema"})," (document structure):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'{\n    "_id": "entity123",                    // Entity ID (Primary Key)\n    "metadata": {                          // Metadata object\n        "key1": "value1",\n        "key2": "value2",\n        "key3": 123,\n        "key4": true,\n        "nested": {\n            "subkey": "subvalue"\n        }\n    },\n    "created_at": ISODate("2024-01-01T00:00:00Z"),  // Optional timestamp\n    "updated_at": ISODate("2024-01-01T00:00:00Z")   // Optional timestamp\n}\n'})}),"\n",(0,i.jsx)(t.h4,{id:"2-metadata_test",children:"2. metadata_test"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Purpose"}),": Test collection for metadata (same schema as ",(0,i.jsx)(t.code,{children:"metadata"}),")"]}),"\n",(0,i.jsx)(t.p,{children:"Used during testing to isolate test data from production data."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"neo4j-schema",children:"Neo4j Schema"}),"\n",(0,i.jsx)(t.h3,{id:"database-information-2",children:"Database Information"}),"\n",(0,i.jsx)(t.p,{children:"The Graph Store is utilized to manage entities and their relationships. It supports both binary and HTTP protocols for interaction, enabling efficient graph traversals and complex relationship queries."}),"\n",(0,i.jsx)(t.h3,{id:"node-types",children:"Node Types"}),"\n",(0,i.jsx)(t.h4,{id:"entity-node",children:"Entity Node"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Label"}),": ",(0,i.jsx)(t.code,{children:":Entity"})]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Properties"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cypher",children:"{\n    id: String,              // Unique entity identifier (REQUIRED)\n    kind_major: String,      // Major entity classification (REQUIRED)\n    kind_minor: String,      // Minor entity classification (optional)\n    name: String,            // Entity name (REQUIRED)\n    created: String,         // ISO 8601 timestamp (REQUIRED)\n    terminated: String       // ISO 8601 timestamp (optional, null = active)\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"relationship-types",children:"Relationship Types"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Dynamic Relationship System"}),": OpenGIN uses a completely generic relationship model where relationship types are not predefined. Users can create any relationship type they need by simply providing a ",(0,i.jsx)(t.code,{children:"name"})," field in the relationship data."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"How it works"}),":"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["User provides relationship with ",(0,i.jsx)(t.code,{children:"name"}),' field (e.g., "reports_to", "depends_on", "manages")']}),"\n",(0,i.jsx)(t.li,{children:"System dynamically creates Neo4j relationship with that type"}),"\n",(0,i.jsxs)(t.li,{children:["Neo4j relationship type becomes the uppercased version or exact value of the ",(0,i.jsx)(t.code,{children:"name"})," field"]}),"\n",(0,i.jsx)(t.li,{children:"No schema validation or predefined list of relationship types"}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"relationship-structure",children:"Relationship Structure"}),"\n",(0,i.jsx)(t.p,{children:"All relationships in Neo4j store the following properties:"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Neo4j Properties"})," (what's actually stored in the graph):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cypher",children:"{\n    Id: String,              // Relationship identifier (uppercase I)\n    Created: DateTime,       // When relationship started (Neo4j datetime type)\n    Terminated: DateTime     // When relationship ended (Neo4j datetime type, null = active)\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Important"}),": The ",(0,i.jsx)(t.code,{children:"name"})," field from the API/Protobuf becomes the ",(0,i.jsx)(t.strong,{children:"relationship TYPE"})," in Neo4j, not a property. It appears in the Cypher syntax as ",(0,i.jsx)(t.code,{children:"[:relationshipType]"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),": The ",(0,i.jsx)(t.code,{children:"direction"})," field is not stored in Neo4j - it's determined by the direction of the arrow in the graph (\u2192 for outgoing, \u2190 for incoming)."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Relationship Types"}),":\nRelationship types are ",(0,i.jsx)(t.strong,{children:"completely dynamic and user-defined"}),". The system does not enforce any predefined relationship types. When creating a relationship, the ",(0,i.jsx)(t.code,{children:"name"})," field from the ",(0,i.jsx)(t.code,{children:"Relationship"})," protobuf message becomes the Neo4j relationship type."]}),"\n",(0,i.jsx)(t.p,{children:"Examples from tests and usage:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"reports_to"}),": Organizational hierarchy (from E2E tests)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"depends_on"}),": Package dependencies (from unit tests)"]}),"\n",(0,i.jsx)(t.li,{children:"Any other name: Users can define any relationship type they need"}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"postgresql-schema",children:"PostgreSQL Schema"}),"\n",(0,i.jsx)(t.h3,{id:"database-information-3",children:"Database Information"}),"\n",(0,i.jsx)(t.h3,{id:"database-information-4",children:"Database Information"}),"\n",(0,i.jsx)(t.p,{children:"The Attribute Store is built on a relational database system to manage structured, time-series attribute data. It ensures data integrity and supports complex querying capabilities through defined schemas."}),"\n",(0,i.jsx)(t.h3,{id:"core-tables",children:"Core Tables"}),"\n",(0,i.jsx)(t.h4,{id:"1-attribute-schema",children:"1. Attribute Schema"}),"\n",(0,i.jsx)(t.p,{children:"This table defines the structure of attributes for different entity kinds. It acts as a registry, specifying properties such as data types and storage strategies (e.g., scalar, list, map), ensuring consistent data handling for specific entity classifications."}),"\n",(0,i.jsx)(t.h4,{id:"2-entity-attributes",children:"2. Entity Attributes"}),"\n",(0,i.jsx)(t.p,{children:"This table serves as a mapping layer, linking unique entity identifiers to the specific attribute definitions stored here. It allows the system to associate concrete data values with the defined structure for any given entity."}),"\n",(0,i.jsx)(t.h3,{id:"dynamic-attribute-tables",children:"Dynamic Attribute Tables"}),"\n",(0,i.jsx)(t.p,{children:"To optimize performance and organize data efficiently, the system automatically creates dedicated tables for attributes based on their entity classification. This approach ensures that attribute data is stored in a structured manner, allowing for faster retrieval and better data management compared to a single monolithic table."}),"\n",(0,i.jsx)(t.h3,{id:"data-integrity",children:"Data Integrity"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"No Distributed Transactions"}),": Currently, OpenGIN doesn't use distributed transactions. Each database operation is independent."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Eventual Consistency"}),": System relies on application-level consistency:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Entity ID is the common key across all databases"}),"\n",(0,i.jsx)(t.li,{children:"Core API orchestrates all operations"}),"\n",(0,i.jsx)(t.li,{children:"Errors are logged but don't rollback previous successful operations"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Future Enhancement"}),": Implement distributed transactions."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"backup-and-restore",children:"Backup and Restore"}),"\n",(0,i.jsx)(t.h3,{id:"metadata-store-backup",children:"Metadata Store Backup"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:'mongodump --uri="mongodb://admin:<your_password>@mongodb:27017/opengin?authSource=admin" \\\n    --out=/backup/mongodb/\n'})}),"\n",(0,i.jsx)(t.h3,{id:"neo4j-backup",children:"Neo4j Backup"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"neo4j-admin dump --database=neo4j --to=/backup/neo4j/neo4j.dump\n"})}),"\n",(0,i.jsx)(t.h3,{id:"postgresql-backup",children:"PostgreSQL Backup"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"pg_dump -h postgres -U postgres -d opengin -F tar -f /backup/postgres/opengin.tar\n"})}),"\n",(0,i.jsxs)(t.p,{children:["See ",(0,i.jsx)(t.a,{href:"/OpenGIN/docs/appendix/operations/backup_integration",children:"Backup Integration Guide"})," for complete backup/restore workflow."]}),"\n",(0,i.jsx)(t.h3,{id:"reference",children:"Reference"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/OpenGIN/docs/overview/what_is_opengin#data-models",children:"Data Models"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/OpenGIN/docs/appendix/datatype",children:"Data Types"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/OpenGIN/docs/appendix/storage",children:"Storage Types"})}),"\n"]}),"\n",(0,i.jsx)(t.hr,{})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453(e,t,n){n.d(t,{R:()=>r,x:()=>o});var a=n(6540);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);