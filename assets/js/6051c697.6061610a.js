"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[620],{122(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/opengin-architecture-diagram-5676ac5422b8615ad1d1e147f1e39842.png"},1406(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/data_flow_sequence_read-9c310429991adbed9c5ececdc1890d20.png"},6341(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/data_flow_sequence_create-93bf9e3150ca75cd529da4fff750fea9.png"},8453(e,t,n){n.d(t,{R:()=>a,x:()=>l});var i=n(6540);const r={},s=i.createContext(r);function a(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:t},e.children)}},9347(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/storage_distribution_opengin-e28cac038f633f2363c05956fad651e4.png"},9757(e,t,n){n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"overview/architecture/index","title":"OpenGIN Architecture Overview","description":"System Overview","source":"@site/docs/overview/architecture/index.md","sourceDirName":"overview/architecture","slug":"/overview/architecture/","permalink":"/OpenGIN/docs/overview/architecture/","draft":false,"unlisted":false,"editUrl":"https://github.com/LDFLK/OpenGIN/tree/main/docs/docs/overview/architecture/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Why OpenGIN?","permalink":"/OpenGIN/docs/overview/why-opengin"},"next":{"title":"Data Flow","permalink":"/OpenGIN/docs/overview/architecture/data_flow"}}');var r=n(4848),s=n(8453);const a={},l="OpenGIN Architecture Overview",d={},o=[{value:"System Overview",id:"system-overview",level:2},{value:"High-Level Architecture Diagram",id:"high-level-architecture-diagram",level:2},{value:"Architecture Layers",id:"architecture-layers",level:2},{value:"1. API Layer (Client-Facing Services)",id:"1-api-layer-client-facing-services",level:3},{value:"Ingestion API",id:"ingestion-api",level:4},{value:"Read API",id:"read-api",level:4},{value:"2. Service Layer",id:"2-service-layer",level:3},{value:"Core API",id:"core-api",level:4},{value:"3. Database Layer",id:"3-database-layer",level:3},{value:"MongoDB",id:"mongodb",level:4},{value:"Neo4j",id:"neo4j",level:4},{value:"PostgreSQL",id:"postgresql",level:4},{value:"4. Supporting Services",id:"4-supporting-services",level:3},{value:"Cleanup Service",id:"cleanup-service",level:4},{value:"Backup/Restore Service",id:"backuprestore-service",level:4},{value:"Data Model",id:"data-model",level:2},{value:"Entity Structure (Protobuf)",id:"entity-structure-protobuf",level:3},{value:"Storage Distribution Strategy",id:"storage-distribution-strategy",level:3},{value:"Data Flow Sequences",id:"data-flow-sequences",level:2},{value:"Create Entity Flow",id:"create-entity-flow",level:3},{value:"Read Entity Flow",id:"read-entity-flow",level:3},{value:"Type System",id:"type-system",level:2},{value:"Type Inference System",id:"type-inference-system",level:3},{value:"Storage Type Inference",id:"storage-type-inference",level:3},{value:"Communication Protocols",id:"communication-protocols",level:2},{value:"Network Architecture",id:"network-architecture",level:2},{value:"Deployment",id:"deployment",level:2},{value:"Containerization",id:"containerization",level:3},{value:"Health Checks",id:"health-checks",level:3},{value:"Service Orchestration",id:"service-orchestration",level:3},{value:"Technology Stack",id:"technology-stack",level:2},{value:"Key Features",id:"key-features",level:2},{value:"1. Polyglot Database Strategy",id:"1-polyglot-database-strategy",level:3},{value:"2. Time-Based Data Support",id:"2-time-based-data-support",level:3},{value:"3. Type Inference",id:"3-type-inference",level:3},{value:"4. Schema Evolution (Not Fully Supported)",id:"4-schema-evolution-not-fully-supported",level:3},{value:"5. Graph Relationships",id:"5-graph-relationships",level:3},{value:"6. Backup &amp; Restore",id:"6-backup--restore",level:3},{value:"7. API Contract-First",id:"7-api-contract-first",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"opengin-architecture-overview",children:"OpenGIN Architecture Overview"})}),"\n",(0,r.jsx)(t.h2,{id:"system-overview",children:"System Overview"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"OpenGIN"})," is a data orchestration and networking framework. It is based on a polyglot database and a microservices-based design that handles entities with metadata, attributes, and relationships. The architecture follows a layered approach with REST/gRPC communication protocols."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"high-level-architecture-diagram",children:"High-Level Architecture Diagram"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"High-Level Architecture Diagram",src:n(122).A+"",width:"1692",height:"1974"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"architecture-layers",children:"Architecture Layers"}),"\n",(0,r.jsx)(t.h3,{id:"1-api-layer-client-facing-services",children:"1. API Layer (Client-Facing Services)"}),"\n",(0,r.jsx)(t.h4,{id:"ingestion-api",children:"Ingestion API"}),"\n",(0,r.jsx)(t.p,{children:"The Ingestion API is responsible for handling entity mutations, including creation, updates, and deletions. Implemented as a Ballerina REST service, it accepts JSON payloads from clients, validates their structure, and converts them into Protobuf Entity messages. It then communicates with the Core API via gRPC and handles the conversion of Protobuf responses back to JSON for the client."}),"\n",(0,r.jsx)(t.h4,{id:"read-api",children:"Read API"}),"\n",(0,r.jsx)(t.p,{children:"The Read API manages entity queries and retrieval. Also built as a Ballerina REST service, it accepts read requests and supports selective field retrieval, filtering, and search capabilities. It interfaces with the Core API using gRPC to fetch data and returns formatted JSON responses to the client."}),"\n",(0,r.jsx)(t.h3,{id:"2-service-layer",children:"2. Service Layer"}),"\n",(0,r.jsx)(t.h4,{id:"core-api",children:"Core API"}),"\n",(0,r.jsx)(t.p,{children:"The Core API acts as the central orchestration service, managing data networking and interactions across the distributed database system. It exposes a gRPC server to handle entity operations such as creation, reading, updating, and deletion."}),"\n",(0,r.jsx)(t.p,{children:"Internally, the service utilizes an Engine Layer to process attributes, manage graph metadata, and perform type and storage inference. The Repository Layer abstracts the interactions with underlying databases, coordinating metadata storage in MongoDB, graph management in Neo4j, and attribute storage in PostgreSQL."}),"\n",(0,r.jsx)(t.h3,{id:"3-database-layer",children:"3. Database Layer"}),"\n",(0,r.jsx)(t.h4,{id:"mongodb",children:"MongoDB"}),"\n",(0,r.jsx)(t.p,{children:"MongoDB is used for flexible metadata storage. Its document-based, schema-less structure allows for efficient handling of the dynamic metadata associated with entities."}),"\n",(0,r.jsx)(t.h4,{id:"neo4j",children:"Neo4j"}),"\n",(0,r.jsx)(t.p,{children:"Neo4j serves as the specialized storage for entities and their relationships. By representing entities as nodes and relationships as directed edges, it optimizes the system for complex graph traversals and relationship-based queries."}),"\n",(0,r.jsx)(t.h4,{id:"postgresql",children:"PostgreSQL"}),"\n",(0,r.jsx)(t.p,{children:"PostgreSQL provides robust storage for time-based attributes. It ensures ACID compliance and supports complex queries, making it ideal for managing time-series data and the evolution of attribute schemas."}),"\n",(0,r.jsx)(t.h3,{id:"4-supporting-services",children:"4. Supporting Services"}),"\n",(0,r.jsx)(t.h4,{id:"cleanup-service",children:"Cleanup Service"}),"\n",(0,r.jsx)(t.p,{children:"The Cleanup Service is a utility designed for database maintenance and testing. It provides a mechanism to clear PostgreSQL tables, drop MongoDB collections, and remove Neo4j nodes and relationships, facilitating a clean state for development and testing environments."}),"\n",(0,r.jsx)(t.h4,{id:"backuprestore-service",children:"Backup/Restore Service"}),"\n",(0,r.jsx)(t.p,{children:"The Backup and Restore Service ensures data persistence and version management. It handles the creation of local backups for all databases, stores them with versioning on GitHub, and supports automated restoration from specific backup releases."}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"data-model",children:"Data Model"}),"\n",(0,r.jsx)(t.h3,{id:"entity-structure-protobuf",children:"Entity Structure (Protobuf)"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-protobuf",children:"message Entity {\n    string id = 1;                              // Unique identifier\n    Kind kind = 2;                              // major/minor classification\n    string created = 3;                         // Creation timestamp (ISO 8601)\n    string terminated = 4;                      // Optional termination timestamp\n    TimeBasedValue name = 5;                    // Entity name with temporal tracking\n    map<string, google.protobuf.Any> metadata = 6;        // Flexible metadata\n    map<string, TimeBasedValueList> attributes = 7;       // Time-based attributes\n    map<string, Relationship> relationships = 8;          // Entity relationships\n}\n\nmessage Kind {\n    string major = 1;                           // Primary classification\n    string minor = 2;                           // Secondary classification\n}\n\nmessage TimeBasedValue {\n    string startTime = 1;                       // Value valid from\n    string endTime = 2;                         // Value valid until (empty = current)\n    google.protobuf.Any value = 3;              // Actual value (any type)\n}\n\nmessage Relationship {\n    string id = 1;                              // Relationship identifier\n    string relatedEntityId = 2;                 // Target entity\n    string name = 3;                            // Relationship type\n    string startTime = 4;                       // Relationship valid from\n    string endTime = 5;                         // Relationship valid until\n    string direction = 6;                       // Relationship direction\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"storage-distribution-strategy",children:"Storage Distribution Strategy"}),"\n",(0,r.jsx)(t.p,{children:"The entity data is strategically distributed across three databases:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Example Entity:"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-json",children:'{\n  "id": "entity123",\n  "kind": {"major": "Person", "minor": "Employee"},\n  "name": "John Doe",\n  "created": "2024-01-01T00:00:00Z",\n  "metadata": {"department": "Engineering", "role": "Engineer"},\n  "attributes": {\n    "expenses": {\n      "columns": ["type", "amount", "date", "category"],\n      "rows": [\n        ["Travel", 500, "2024-01-15", "Business"],\n        ["Meals", 120, "2024-01-16", "Entertainment"],\n        ["Equipment", 300, "2024-01-17", "Office"]\n      ]\n    }\n  },\n  "relationships": {"reports_to": "manager123"}\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Storage Distribution:"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Storage-Distribution-of-openGIN",src:n(9347).A+"",width:"4648",height:"2204"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"data-flow-sequences",children:"Data Flow Sequences"}),"\n",(0,r.jsx)(t.h3,{id:"create-entity-flow",children:"Create Entity Flow"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Data-Flow-Sequence-Create",src:n(6341).A+"",width:"2964",height:"2812"})}),"\n",(0,r.jsx)(t.h3,{id:"read-entity-flow",children:"Read Entity Flow"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Data-Flow-Sequence-Read",src:n(1406).A+"",width:"2968",height:"2812"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"type-system",children:"Type System"}),"\n",(0,r.jsx)(t.h3,{id:"type-inference-system",children:"Type Inference System"}),"\n",(0,r.jsx)(t.p,{children:"The Type Inference System automatically detects data types to eliminate the need for manual specification. It identifies primitive types such as integers, floats, strings, and booleans, as well as special temporal types like dates, times, and datetimes, assigning the appropriate type based on the input value's format."}),"\n",(0,r.jsx)(t.h3,{id:"storage-type-inference",children:"Storage Type Inference"}),"\n",(0,r.jsx)(t.p,{children:"The Storage Type Inference mechanism determines the optimal storage structure for data. It categorizes input into formats such as tabular (for data with rows and columns), graph (for nodes and edges), list, scalar, or map, ensuring efficient storage and retrieval."}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"communication-protocols",children:"Communication Protocols"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Layer"}),(0,r.jsx)(t.th,{children:"Protocol"}),(0,r.jsx)(t.th,{children:"Format"}),(0,r.jsx)(t.th,{children:"Port"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Client \u2194 Ingestion API"}),(0,r.jsx)(t.td,{children:"HTTP/REST"}),(0,r.jsx)(t.td,{children:"JSON"}),(0,r.jsx)(t.td,{children:"8080"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Client \u2194 Read API"}),(0,r.jsx)(t.td,{children:"HTTP/REST"}),(0,r.jsx)(t.td,{children:"JSON"}),(0,r.jsx)(t.td,{children:"8081"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"APIs \u2194 Core API"}),(0,r.jsx)(t.td,{children:"gRPC"}),(0,r.jsx)(t.td,{children:"Protobuf"}),(0,r.jsx)(t.td,{children:"50051"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Core API \u2194 MongoDB"}),(0,r.jsx)(t.td,{children:"MongoDB Wire Protocol"}),(0,r.jsx)(t.td,{children:"BSON"}),(0,r.jsx)(t.td,{children:"27017"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Core API \u2194 Neo4j"}),(0,r.jsx)(t.td,{children:"Bolt Protocol"}),(0,r.jsx)(t.td,{children:"Cypher"}),(0,r.jsx)(t.td,{children:"7687"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Core API \u2194 PostgreSQL"}),(0,r.jsx)(t.td,{children:"PostgreSQL Wire Protocol"}),(0,r.jsx)(t.td,{children:"SQL"}),(0,r.jsx)(t.td,{children:"5432"})]})]})]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"network-architecture",children:"Network Architecture"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Docker Network"}),": ",(0,r.jsx)(t.code,{children:"ldf-network"})," (bridge network)\nAll services run within the same Docker network:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Container-based service discovery"}),"\n",(0,r.jsx)(t.li,{children:"Internal communication via container names"}),"\n",(0,r.jsx)(t.li,{children:"Health checks ensure proper startup sequencing"}),"\n",(0,r.jsx)(t.li,{children:"Volume persistence for data storage"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Exposed Ports:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"8080"})," - Ingestion API (external access)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"8081"})," - Read API (external access)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"50051"})," - Core API (can be internal only)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"27017"})," - MongoDB (development access)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"7474/7687"})," - Neo4j (development access)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"5432"})," - PostgreSQL (development access)"]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"deployment",children:"Deployment"}),"\n",(0,r.jsx)(t.h3,{id:"containerization",children:"Containerization"}),"\n",(0,r.jsx)(t.p,{children:"The system leverages Docker and Docker Compose for containerization, running all services within a shared bridge network. This setup ensures consistent environments and manages the persistence of database storage through volumes."}),"\n",(0,r.jsx)(t.h3,{id:"health-checks",children:"Health Checks"}),"\n",(0,r.jsx)(t.p,{children:"Integrated health checks are configured for all services to ensure proper startup sequencing. The Core API waits for databases to be ready, while the Ingestion and Read APIs wait for the Core API, ensuring a stable initialization process."}),"\n",(0,r.jsx)(t.h3,{id:"service-orchestration",children:"Service Orchestration"}),"\n",(0,r.jsx)(t.p,{children:"Services use dependency management to start in the correct order: databases initialize first, followed by the Core API, and finally the Ingestion and Read APIs. A default Docker Compose profile runs all core services, while a separate 'cleanup' profile is available to trigger the database cleanup service."}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"technology-stack",children:"Technology Stack"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Component"}),(0,r.jsx)(t.th,{children:"Technology"}),(0,r.jsx)(t.th,{children:"Language"}),(0,r.jsx)(t.th,{children:"Purpose"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Ingestion API"}),(0,r.jsx)(t.td,{children:"Ballerina"}),(0,r.jsx)(t.td,{children:"Ballerina"}),(0,r.jsx)(t.td,{children:"REST API for mutations"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Read API"}),(0,r.jsx)(t.td,{children:"Ballerina"}),(0,r.jsx)(t.td,{children:"Ballerina"}),(0,r.jsx)(t.td,{children:"REST API for queries"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Core API"}),(0,r.jsx)(t.td,{children:"Go + gRPC"}),(0,r.jsx)(t.td,{children:"Go"}),(0,r.jsx)(t.td,{children:"Business logic orchestration"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"MongoDB"}),(0,r.jsx)(t.td,{children:"MongoDB 5.0+"}),(0,r.jsx)(t.td,{children:"-"}),(0,r.jsx)(t.td,{children:"Metadata storage"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Neo4j"}),(0,r.jsx)(t.td,{children:"Neo4j 5.x"}),(0,r.jsx)(t.td,{children:"-"}),(0,r.jsx)(t.td,{children:"Graph storage"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"PostgreSQL"}),(0,r.jsx)(t.td,{children:"PostgreSQL 14+"}),(0,r.jsx)(t.td,{children:"-"}),(0,r.jsx)(t.td,{children:"Attribute storage"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Protobuf"}),(0,r.jsx)(t.td,{children:"Protocol Buffers"}),(0,r.jsx)(t.td,{children:"-"}),(0,r.jsx)(t.td,{children:"Service communication"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Docker"}),(0,r.jsx)(t.td,{children:"Docker + Compose"}),(0,r.jsx)(t.td,{children:"-"}),(0,r.jsx)(t.td,{children:"Containerization"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Testing"}),(0,r.jsx)(t.td,{children:"Go test, Bal test, Python"}),(0,r.jsx)(t.td,{children:"Multiple"}),(0,r.jsx)(t.td,{children:"Unit & E2E tests"})]})]})]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsx)(t.h3,{id:"1-polyglot-database-strategy",children:"1. Polyglot Database Strategy"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Optimized Storage"}),": Each database serves its best use case"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Data Separation"}),": Clear boundaries between metadata, entities, and attributes"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Scalability"}),": Independent scaling of each database"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"2-time-based-data-support",children:"2. Time-Based Data Support"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Temporal Attributes"}),": Track attribute values over time"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Temporal Relationships"}),": Time-bound entity relationships"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Historical Queries"}),": Query data at specific points in time (activeAt parameter)"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"3-type-inference",children:"3. Type Inference"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Automatic Detection"}),": No manual type specification required"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Rich Type System"}),": Supports primitives and special types"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Storage Optimization"}),": Determines optimal storage based on data structure"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"4-schema-evolution-not-fully-supported",children:"4. Schema Evolution (Not Fully Supported)"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Dynamic Schemas"}),": PostgreSQL tables created on-demand"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Attribute Flexibility"}),": New attributes don't require migrations"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Kind-Based Organization"}),": Attributes organized by entity kind"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"5-graph-relationships",children:"5. Graph Relationships"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Native Graph Storage"}),": Neo4j for optimal relationship queries"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Bi-directional Support"}),": Forward and reverse relationship traversal"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Relationship Properties"}),": Rich metadata on relationships"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"6-backup--restore",children:"6. Backup & Restore"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Polyglot Database Backup"}),": Coordinated backups across all databases"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Version Management"}),": GitHub-based version control"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"One-Command Restore"}),": Simple restoration from any version"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"7-api-contract-first",children:"7. API Contract-First"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"OpenAPI Specifications"}),": APIs defined before implementation"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Code Generation"}),": Service scaffolding from contracts"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Documentation"}),": Swagger UI for interactive API docs"]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/OpenGIN/docs/overview/architecture/data_flow",children:"How It Works"})," - Detailed data flow documentation"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/OpenGIN/docs/appendix/datatype",children:"Data Types"})," - Type inference system details"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/OpenGIN/docs/appendix/storage",children:"Storage Types"})," - Storage type inference details"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/OpenGIN/docs/appendix/operations/backup_integration",children:"Backup Integration"})," - Backup and restore guide"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/OpenGIN/docs/overview/architecture/core-api",children:"Core API"})," - Core API documentation"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/OpenGIN/docs/overview/architecture/api-layer-details",children:"Service APIs"})," - Service APIs documentation"]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);